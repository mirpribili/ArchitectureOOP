# Архитектура ООП
### Наследование
- избегаем
### Инкапсуляция
- позволяет менять реализацию независимо
### Полиморфизм
- В идеале полиформизм может позволить избавиться от IF || SWITCH
- enum = для каждлго члена с пом полиформизма можно определить свою реализацию метода и тогда избавимся от switch
- - особенно для instanceOf
- перегрузка методов не полиформизм ТК она не связана с наследованием
## UML
- упрощает моделирование в области проектирования програмн. обесп.
- Class diagram - статическая структурная диаграмма описывающая систему, ее классы и зависимости
- Sequence diagram - диаграма следовательности
### Class diagram Отношения между классами
- Агрегация [class A] (o)----- [class B] (ромбик не закрашен)
  - значит класс А содержит в себе коллекцию объектов класса Б
  - Обозначает отношение «has a
    - профессор и студенты
    - уничтожение не приводит к уничтожению содержимого
    - пишут для сборщика мусора
- Композиция [class A] (x)----- [class B] (ромбик закрашен)
  - состоит из объектов класса Б
  - Уничтожение контейнера приводит к уничтожению содержимог
    - машина из деталей
  - принципиально для C++
- Зависимость [class A] ------> [class B]
  - боремся с ними)
  - Показывает, что один класс вызывает метод (или конструктор) другого класса
- Генерализация ( ---|>  ?)
  - Имплементация например 
  - Обозначает отношение «is a»
  - Показывает, что один класс является более частной формой другого
  - **Реализация** (стрелочка штриховка и пустой треугольник)
    - имплементация интерфейса
### SOLID
- Design smells запашки
    - Rigidity систему тяжело изменять влечет цепочку изменений
        - Жесткость
    - Fragility - ухо почесал хвост, отвалился. что-то неожиданное сломалось
        - Хрупкость
    - Immobility - части не могут быть переиспользованы в другой системе
        - Неподвижность
    - Viscosity - дешевле применить хак, чем сделать хорошо.
        - Вязкость
    - Needless repetition - имеют место структуры которые можно объединить в одну абстракцию.
        - Ненужное повторение
    - Needless complexity - в наличие то что создает сложности сейчас но понадобится якобы потом.
    - Opacity - код тяжело читать и понимать
        - Непрозрачность

#### Принципы SOLID
1. S = Single-Responsibility Principle (SRP)
   - Принцип Единой ответственности
     - у класса должна быть одна ответственность
     - у класса должна быть одна причина для изменения
     - ответственность = ось изменения
     - валидация изменилась = 1 ось изменения
     - формат JSON изменилась = 1 ось изменения
     - не допускает связи ответственностей
     - **Самый простой с точки формулировки, самый сложный в применении**
     - **Ось изменения становится осью только тогда, когда изменения !!происходят!! (иначе получаем needless complexity)**
     - Пример нарушения СМ рис [A1] (две оси изменения, GUI тянется = решение [A2])
2. O = Open for extension - Closed for modification Principle (OCP)
   - Принцип "Открыто-Закрыто"
   - открыты для расширения и закрыты для изменения
     - можем изменить поведение без изм. кода
   - Template Method
     - если есть 2 метода в которых только "сердцевина" разная
       - то делают класс базовый который забирает себе все кроме "сердцевины"
       - и вместо нее объявляет а бстрактный метод
       - и этот абстрактный метод и реализует у себя оба метода после наследования базового класса
   > Пример нарушения и починки см. [A3], [A4].
3. L = Liskov Substitution Principle (LSP)
   - Substitution - замещение
   - Принцип замещения Лискова
   - Наследующий класс должен дополнять, а не замещать поведение базового класса.
     - нарушение приводит к Fragility и нарушению OCP
     - Более точный подход к наследованию. (отношение is-a еще и о поведении)
       - в идеале замена наследника одного на другого не приводит к решительным проблемам.
       - или мы создаем некоторые ожидания в отношении наследников и они им удовлетворяют
   - Контракт на классы стоит специфицировать юнит-тестами
   > Пример нарушения. Есть класс прямоугольник и наследник класс квадрат. И есть метод где мы не можем наследника прямоугольника применить [A5]
4. I = Interface-Segregation Principle (ISP)
   - Принцип разделения интерфейса
   - Клиенты не должны зависеть на методы, которые они не используют.
     - нарушение приводит к тому, что клиенты через такой супер-интерфейс зависят друг на друга.
5. D = Dependency-Inversion Principle (DIP)
   - Принцип Инверсии зависимостей
   - Модули верхних уровней не должны зависеть от моделей нижних. Оба должны зависеть от абстракций.
   - Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.
   - устраняет rigidity, fragility, immobility.
    > Пример рис [A6] три слоя приложения. Policy Layer --> Mechanism Layer --> Utility Layer
    > 
    > ошибка в том что Policy зависит от Utility. РЕШЕНИЕ справа.
    > 
    > Пример рис [A7]. Проблема в том что один интерфейс !частично! используется в 3х классах. Решение справа. 
### Многопоточность
- две разные концепции
  1. синхронная и асинхронная модель программирования
  2. однопоточная и многопоточная среда.
     1. синхронная и асинхронная модель может работать как однопоточно, так и многопоточно.
  - Многопоточность это способность операц. системы. в рамках одного процесса поддерживать несколько потоков.
  - переключение между потоками, как правило, быстрее и дешевле чем между процессами.
  - ускорение приложений с вводом и выводом данных. За счет отсутствия простоев при вводе и выводе.
  - потоки удобны при нескольких действиях сразу. Как то запросы нескольких пользователей.
  - логирование в отд. потоке. GUI, контроль
#### Асинхронное программирование
  - В отличие от модели синхронного программирования, здесь поток запуская некую задачу может остановить ее на некотором промежутке времени ее выполнения.
  - **Эффективность можно свести к 0 у многопоточного процессора если потоки зависят друг от друга**
#### Виды многопоточности
  - Simultaneous Multithreading — SMT. Одновременная многопоточность. Несколько потоков выполняются одновременно, а не последовательно, как в во "временной многопоточности".
  - Temporal multithreading. Временная многопоточ. Поток работает в своем контексте пока не происходит:
    - прерывание, 
    - системный вызов 
    - истечет отведенное время.
    1. Крупнозернистая (Coarse-grained multithreading (CGMT), Blocked
       multithreading).
    2. Тонкозернистая (Fine-grained multithreading (FGMT), Interleaved
       multithreading )
##### Многопоточность определяется:
   1. Возможностями процессора
   2. Возм. операц. системы.
   3. Возм. языка программирования.
 - Задания или нити? 
   - для тяжелых задач задания для легких где не надо занимать много оперативки в критичный момент - нити.
   - нити POSIX THREADS - фраймворк для джавы
40,57